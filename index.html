/**
* @OnlyCurrentDoc
* このスクリプトは、指定されたデザインテンプレートに基づきGoogleスライドを自動生成します。
* Version: 17.0 (Generalized Version)
* Prompt Design: まじん式プロンプト
* Author: Googleスライド自動生成マスター
* Description: 指定されたslideData配列とカスタムメニューの設定に基づき、Googleのデザイン原則に準拠したスライドを生成します。
*/


// --- 1. 実行設定 ---
const SETTINGS = {
SHOULD_CLEAR_ALL_SLIDES: true,
TARGET_PRESENTATION_ID: null
};

// --- 2. マスターデザイン設定 (Pixel Perfect Ver.) ---
const CONFIG = {
BASE_PX: { W: 960, H: 540 },

// レイアウトの基準となる不変のpx値
POS_PX: {
titleSlide: {
logo:       { left: 55,  top: 105,  width: 135 },
title:      { left: 50,  top: 200, width: 830, height: 90 },
date:       { left: 50,  top: 450, width: 250, height: 40 },
},

// 共通ヘッダーを持つ各スライド  
contentSlide: {  
  headerLogo:     { right: 20, top: 20, width: 75 },  
  title:          { left: 25, top: 50,  width: 830, height: 65 },  
  titleUnderline: { left: 25, top: 118, width: 260, height: 4 },  
  subhead:        { left: 25, top: 130, width: 830, height: 40 },  
  body:           { left: 25, top: 172, width: 910, height: 290 },  
  twoColLeft:     { left: 25,  top: 172, width: 440, height: 290 },  
  twoColRight:    { left: 495, top: 172, width: 440, height: 290 }  
},  
processSlide: {  
  headerLogo:     { right: 20, top: 20, width: 75 },  
  title:          { left: 25, top: 50,  width: 830, height: 65 },  
  titleUnderline: { left: 25, top: 118, width: 260, height: 4 },  
  subhead:        { left: 25, top: 130, width: 830, height: 40 },  
  area:           { left: 25, top: 152, width: 910, height: 290 }  
},  
cardsSlide: { // This POS_PX is used by both cards and headerCards
  headerLogo:     { right: 20, top: 20, width: 75 },  
  title:          { left: 25, top: 50,  width: 830, height: 65 },  
  titleUnderline: { left: 25, top: 118, width: 260, height: 4 },  
  subhead:        { left: 25, top: 130, width: 830, height: 40 },  
  gridArea:       { left: 25, top: 160, width: 910, height: 290 }  
},  
sectionSlide: {  
  title:      { left: 55, top: 230, width: 840, height: 80 },  
  ghostNum:   { left: 35, top: 120, width: 400, height: 200 }
},

footer: {  
  leftText:  { left: 15, top: 505, width: 250, height: 20 },  
  rightPage: { right: 15, top: 505, width: 50,  height: 20 }  
},  
bottomBar: { left: 0, top: 534, width: 960, height: 6 }  

},

FONTS: {
family: 'Arial', // デフォルト、プロパティから動的に変更可能
sizes: {
title: 40, date: 16, sectionTitle: 38, contentTitle: 28, subhead: 18,
body: 14, footer: 9, chip: 11, laneTitle: 13, small: 10,
processStep: 14, axis: 12, ghostNum: 180
}
},
COLORS: {
primary_color: '#4285F4', text_primary: '#333333', background_white: '#FFFFFF',
background_gray: '#f8f9fa', faint_gray: '#e8eaed', lane_title_bg: '#f8f9fa',
table_header_bg: '#f8f9fa', lane_border: '#dadce0', card_bg: '#ffffff',
card_border: '#dadce0', neutral_gray: '#9e9e9e', ghost_gray: '#efefed'
},
DIAGRAM: {
laneGap_px: 24, lanePad_px: 10, laneTitle_h_px: 30, cardGap_px: 12,
cardMin_h_px: 48, cardMax_h_px: 70, arrow_h_px: 10, arrowGap_px: 8
},

LOGOS: {
header: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/Google_2015_logo.svg/640px-Google_2015_logo.svg.png',
closing: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/Google_2015_logo.svg/640px-Google_2015_logo.svg.png'
},

FOOTER_TEXT: `© ${new Date().getFullYear()} Google Inc.`
};

// --- 3. スライドデータ（サンプル：必ず置換してください） ---
const slideData = [
  { type: 'title', title: '新規採用者教育と既存体制の改善計画', date: '2025.09.18', notes: '本日は、新規採用者の教育計画と、それに伴う既存教育体制の改善点についてご報告します。' },
  { type: 'content', title: '本日お伝えすること', points: ['新規採用者の配属と教育計画', '既存教育体制の課題と改善', '今後の展望とアクションプラン'], notes: '本日はこちらの3つの章立てでご説明します。まず新規採用者の計画、次に既存体制の課題、最後に今後のアクションプランです。' },
  { type: 'section', title: '1. 新規採用者の配属と教育計画', notes: '最初の章では、新規採用者の配属と具体的な教育計画についてご説明します。' },
  {
    type: 'bulletCards',
    title: '新規採用者の個別教育プラン',
    subhead: '外半セクション配属の2名に対する個別アプローチ',
    items: [
      {
        title: '長井氏への教育プラン',
        desc: '担当は**岩立氏**。使用機種の違いを考慮し、[[旧ホミスの操作]]に重点を置いた指導を実施'
      },
      {
        title: '手塚氏への教育プラン',
        desc: '担当は**村上氏**。[[電子カルテ操作]]または[[正しい算定方法]]に焦点を当てた指導を実施'
      },
      {
        title: '共通サポート体制',
        desc: '担当者不在時は**相馬ひとみ氏**がサポート。本郷/腰ヶ谷勤務も考慮した柔軟な体制'
      }
    ],
    notes: 'まず、新規採用者である長井様と手塚様の教育プランです。お二人は外半セクションへ配属となりますが、それぞれ使用するシステムが異なるため、個別担当制で教育を進めます。長井様は岩立さん、手塚様は村上さんが担当します。また、共通のサポートとして相馬さんが担当者不在時をフォローします。'
  },
  {
    type: 'process',
    title: '5日間の初期研修計画',
    subhead: '理解度を可視化し、着実なスキルアップを促す',
    steps: [
      '算定管理量のチェックシート作成',
      '研修スケジュールの策定（5日間）',
      'スケジュールと卒業基準の連携',
      '進捗状況の定期的な確認',
      '習熟度に応じた個別フォローアップ'
    ],
    notes: '具体的な研修計画として、こちらの5ステップを予定しています。算定管理量のチェックシートを用いて理解度を確認し、スケジュールと卒業基準を明確に連携させることで、着実なスキルアップを目指します。'
  },
  { type: 'section', title: '2. 既存教育体制の課題と改善', notes: '次に、既存の教育体制における課題と、その改善策についてご説明します。' },
  {
    type: 'content',
    title: '新システム導入に伴う教育体制の強化',
    subhead: '新ホミス導入拡大を見据えた対応',
    points: [
      '[[教育対象者の拡大]]: 外半セクションでの新ホミス導入増加の可能性',
      '[[実践重視の教育]]: デモ環境の制限から、実環境での経験が重要',
      '[[理解度の深掘り]]: 新シートを用いて個々の習熟度を正確に把握し指導'
    ],
    notes: '次に、既存教育体制の課題です。特に、新ホミスの導入が拡大しており、教育対象者が増える可能性があります。デモ環境に制限があるため、実環境でのOJTを重視し、新しいチェックシートで個々の理解度を深掘りしていく方針です。'
  },
  {
    type: 'cards',
    title: 'その他教育課題と関連業務',
    columns: 3,
    items: [
      {
        title: '重点教育項目の確認',
        desc: '在宅自己注射管理料に関する理解度の再確認と徹底'
      },
      {
        title: '継続的な評価とFB',
        desc: '若林氏の配属状況と評価フィードバックの議論を継続'
      },
      {
        title: '業務引き継ぎの実施',
        desc: '岡部氏の異動に伴う採用業務を2人体制で確実に引き継ぎ'
      }
    ],
    notes: 'その他、在宅自己注射管理料の理解度確認や、若林様の評価フィードバック、岡部様の異動に伴う採用業務の引き継ぎなど、関連業務も並行して進めてまいります。'
  },
  { type: 'section', title: '3. 今後の展望とアクションプラン', notes: '最後の章では、教育部門の目標と、具体的な次のアクションについて共有します。' },
  {
    type: 'content',
    title: '教育部門の今期目標',
    subhead: '前年度の方針を踏襲し、定着支援を強化',
    points: [
      '**基本方針**: 前年度の目標設定と方針を踏襲',
      '**村上氏の意欲**: [[新入社員が長く働き続けられる環境作り]]への貢献',
      '**体制強化**: 教育担当者間の連携を密にし、サポート体制を充実'
    ],
    notes: '教育部門の今期目標は、基本的には前年度の方針を踏襲します。村上さんからは、新入社員が安心して長く働ける環境作りに貢献したいとの力強いコメントをいただいています。'
  },
  {
    type: 'headerCards',
    title: '推奨される次のステップ (Next Action)',
    columns: 2,
    items: [
      {
        title: '今井 稔 氏 → 村上 はるみ 氏',
        desc: '若林氏と富長氏に関する[[フィードバック資料の共有]]'
      },
      {
        title: '今井 稔 氏 → 土田 氏',
        desc: '採用チャットへ[[村上はるみ氏を追加]]するよう相談'
      }
    ],
    notes: '最後に、具体的な次のアクションです。私から村上さんへ若林様と富長様のフィードバック資料を共有します。また、土田さんにご相談の上、村上さんを採用関連のチャットにご招待します。'
  },
  { type: 'closing', notes: 'ご清聴いただき、ありがとうございました。ご質問などございましたら、よろしくお願いいたします。' }
];


// --- 4. メイン実行関数（エントリーポイント） ---
let __SECTION_COUNTER = 0; // 章番号カウンタ（ゴースト数字用）

/**
 * プレゼンテーション生成のメイン関数
 * 実行時間: 約3-6分
 * 最大スライド数: 50枚
 */
function generatePresentation() {
  const userSettings = PropertiesService.getScriptProperties().getProperties();
  if (userSettings.primaryColor) CONFIG.COLORS.primary_color = userSettings.primaryColor;
  if (userSettings.footerText) CONFIG.FOOTER_TEXT = userSettings.footerText;
  if (userSettings.headerLogoUrl) CONFIG.LOGOS.header = userSettings.headerLogoUrl;
  if (userSettings.closingLogoUrl) CONFIG.LOGOS.closing = userSettings.closingLogoUrl;
  if (userSettings.fontFamily) CONFIG.FONTS.family = userSettings.fontFamily;

  let presentation;
  try {
    presentation = SETTINGS.TARGET_PRESENTATION_ID
      ? SlidesApp.openById(SETTINGS.TARGET_PRESENTATION_ID)
      : SlidesApp.getActivePresentation();
    if (!presentation) throw new Error('対象のプレゼンテーションが見つかりません。');

    if (SETTINGS.SHOULD_CLEAR_ALL_SLIDES) {
      const slides = presentation.getSlides();
      for (let i = slides.length - 1; i >= 0; i--) slides[i].remove();
    }

    __SECTION_COUNTER = 0;

    const layout = createLayoutManager(presentation.getPageWidth(), presentation.getPageHeight());

    let pageCounter = 0;
    for (const data of slideData) {
      try {
        const generator = slideGenerators[data.type];
        if (data.type !== 'title' && data.type !== 'closing') pageCounter++;
        if (generator) {
          const slide = presentation.appendSlide(SlidesApp.PredefinedLayout.BLANK);
          generator(slide, data, layout, pageCounter);

          if (data.notes) {
            try {
              const notesShape = slide.getNotesPage().getSpeakerNotesShape();
              if (notesShape) {
                notesShape.getText().setText(data.notes);
              }
            } catch (e) {
              Logger.log(`スピーカーノートの設定に失敗しました: ${e.message}`);
            }
          }
        }
      } catch (e) {
        Logger.log(`スライドの生成をスキップしました (エラー発生)。 Type: ${data.type}, Title: ${data.title || 'N/A'}, Error: ${e.message}`);
      }
    }

  } catch (e) {
    Logger.log(`処理が中断されました: ${e.message}\nStack: ${e.stack}`);
  }
}

// --- 5. カスタムメニュー設定関数 ---
function onOpen(e) {
  SlidesApp.getUi()
    .createMenu('カスタム設定')
    .addItem('🎨 スライドを生成', 'generatePresentation')
    .addSeparator()
    .addSubMenu(SlidesApp.getUi().createMenu('⚙️ 設定')
      .addItem('プライマリカラー', 'setPrimaryColor')
      .addItem('フォント', 'setFont')
      .addItem('フッターテキスト', 'setFooterText')
      .addItem('ヘッダーロゴ', 'setHeaderLogo')
      .addItem('クロージングロゴ', 'setClosingLogo'))
    .addItem('🔄 リセット', 'resetSettings')
    .addToUi();
}

// プライマリカラー設定
function setPrimaryColor() {
  const ui = SlidesApp.getUi();
  const props = PropertiesService.getScriptProperties();
  const currentValue = props.getProperty('primaryColor') || '#4285F4';
  
  const result = ui.prompt(
    'プライマリカラー設定',
    `カラーコードを入力してください（例: #4285F4）\n現在値: ${currentValue}\n\n空欄で既定値にリセットされます。`,
    ui.ButtonSet.OK_CANCEL
  );
  
  if (result.getSelectedButton() === ui.Button.OK) {
    const value = result.getResponseText().trim();
    if (value === '') {
      props.deleteProperty('primaryColor');
      ui.alert('プライマリカラーをリセットしました。');
    } else {
      props.setProperty('primaryColor', value);
      ui.alert('プライマリカラーを保存しました。');
    }
  }
}

// フォント設定（プルダウン形式）
function setFont() {
  const ui = SlidesApp.getUi();
  const props = PropertiesService.getScriptProperties();
  const currentValue = props.getProperty('fontFamily') || 'Arial';
  
  const fonts = [
    'Arial',
    'Noto Sans JP',
    'M PLUS 1p',
    'Noto Serif JP'
  ];
  
  const fontList = fonts.map((font, index) => 
    `${index + 1}. ${font}${font === currentValue ? ' (現在)' : ''}`
  ).join('\n');
  
  const result = ui.prompt(
    'フォント設定',
    `使用するフォントの番号を入力してください:\n\n${fontList}\n\n※ 空欄で既定値（Arial）にリセット`,
    ui.ButtonSet.OK_CANCEL
  );
  
  if (result.getSelectedButton() === ui.Button.OK) {
    const input = result.getResponseText().trim();
    if (input === '') {
      props.deleteProperty('fontFamily');
      ui.alert('フォントをリセットしました（Arial）。');
    } else {
      const index = parseInt(input) - 1;
      if (index >= 0 && index < fonts.length) {
        props.setProperty('fontFamily', fonts[index]);
        ui.alert(`フォントを「${fonts[index]}」に設定しました。`);
      } else {
        ui.alert('無効な番号です。設定をキャンセルしました。');
      }
    }
  }
}

// フッターテキスト設定
function setFooterText() {
  const ui = SlidesApp.getUi();
  const props = PropertiesService.getScriptProperties();
  const currentValue = props.getProperty('footerText') || '未設定';
  
  const result = ui.prompt(
    'フッターテキスト設定',
    `フッターに表示するテキストを入力してください\n現在値: ${currentValue}\n\n空欄でリセットされます。`,
    ui.ButtonSet.OK_CANCEL
  );
  
  if (result.getSelectedButton() === ui.Button.OK) {
    const value = result.getResponseText().trim();
    if (value === '') {
      props.deleteProperty('footerText');
      ui.alert('フッターテキストをリセットしました。');
    } else {
      props.setProperty('footerText', value);
      ui.alert('フッターテキストを保存しました。');
    }
  }
}

// ヘッダーロゴ設定
function setHeaderLogo() {
  const ui = SlidesApp.getUi();
  const props = PropertiesService.getScriptProperties();
  const currentValue = props.getProperty('headerLogoUrl') || '未設定';
  
  const result = ui.prompt(
    'ヘッダーロゴ設定',
    `ヘッダーロゴのURLを入力してください\n現在値: ${currentValue}\n\n空欄でリセットされます。`,
    ui.ButtonSet.OK_CANCEL
  );
  
  if (result.getSelectedButton() === ui.Button.OK) {
    const value = result.getResponseText().trim();
    if (value === '') {
      props.deleteProperty('headerLogoUrl');
      ui.alert('ヘッダーロゴをリセットしました。');
    } else {
      props.setProperty('headerLogoUrl', value);
      ui.alert('ヘッダーロゴを保存しました。');
    }
  }
}

// クロージングロゴ設定
function setClosingLogo() {
  const ui = SlidesApp.getUi();
  const props = PropertiesService.getScriptProperties();
  const currentValue = props.getProperty('closingLogoUrl') || '未設定';
  
  const result = ui.prompt(
    'クロージングロゴ設定',
    `クロージングページのロゴURLを入力してください\n現在値: ${currentValue}\n\n空欄でリセットされます。`,
    ui.ButtonSet.OK_CANCEL
  );
  
  if (result.getSelectedButton() === ui.Button.OK) {
    const value = result.getResponseText().trim();
    if (value === '') {
      props.deleteProperty('closingLogoUrl');
      ui.alert('クロージングロゴをリセットしました。');
    } else {
      props.setProperty('closingLogoUrl', value);
      ui.alert('クロージングロゴを保存しました。');
    }
  }
}

function resetSettings() {
  const ui = SlidesApp.getUi();
  const result = ui.alert('設定のリセット', 'すべてのカスタム設定をリセットしますか？', ui.ButtonSet.YES_NO);
  
  if (result === ui.Button.YES) {
    PropertiesService.getScriptProperties().deleteAllProperties();
    ui.alert('すべての設定をリセットしました。\n\n• プライマリカラー: #4285F4\n• フォント: Arial\n• フッター/ロゴ: 未設定');
  }
}

// --- 6. スライド生成ディスパッチャ ---
const slideGenerators = {
  title: createTitleSlide,
  section: createSectionSlide,
  content: createContentSlide,
  process: createProcessSlide,
  cards: createCardsSlide,
  headerCards: createHeaderCardsSlide,
  bulletCards: createBulletCardsSlide,
  closing: createClosingSlide,
};

// --- 7. スライド生成関数群 ---
function createTitleSlide(slide, data, layout) {
  slide.getBackground().setSolidFill(CONFIG.COLORS.background_white);

  const logoRect = layout.getRect('titleSlide.logo');
  try {
    const logo = slide.insertImage(CONFIG.LOGOS.header);
    const aspect = logo.getHeight() / logo.getWidth();
    logo.setLeft(logoRect.left).setTop(logoRect.top).setWidth(logoRect.width).setHeight(logoRect.width * aspect);
  } catch (e) {
    // 画像挿入に失敗した場合はスキップして他の要素を描画
  }

  const titleRect = layout.getRect('titleSlide.title');
  const titleShape = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, titleRect.left, titleRect.top, titleRect.width, titleRect.height);
  setStyledText(titleShape, data.title, { size: CONFIG.FONTS.sizes.title, bold: true });

  const dateRect = layout.getRect('titleSlide.date');
  const dateShape = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, dateRect.left, dateRect.top, dateRect.width, dateRect.height);
  dateShape.getText().setText(data.date || '');
  applyTextStyle(dateShape.getText(), { size: CONFIG.FONTS.sizes.date });

  drawBottomBar(slide, layout);
}

function createSectionSlide(slide, data, layout, pageNum) {
  slide.getBackground().setSolidFill(CONFIG.COLORS.background_gray);

  // 透かし番号：sectionNo > タイトル先頭の数字 > 自動連番
  __SECTION_COUNTER++;
  const parsedNum = (() => {
    if (Number.isFinite(data.sectionNo)) return Number(data.sectionNo);
    const m = String(data.title || '').match(/^\s*(\d+)[\.．]/);
    return m ? Number(m[1]) : __SECTION_COUNTER;
  })();
  const num = String(parsedNum).padStart(2, '0');

  const ghostRect = layout.getRect('sectionSlide.ghostNum');
  const ghost = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, ghostRect.left, ghostRect.top, ghostRect.width, ghostRect.height);
  ghost.getText().setText(num);
  applyTextStyle(ghost.getText(), { size: CONFIG.FONTS.sizes.ghostNum, color: CONFIG.COLORS.ghost_gray, bold: true });
  try { ghost.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); } catch(e) {}

  const titleRect = layout.getRect('sectionSlide.title');
  const titleShape = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, titleRect.left, titleRect.top, titleRect.width, titleRect.height);
  titleShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);
  setStyledText(titleShape, data.title, { size: CONFIG.FONTS.sizes.sectionTitle, bold: true, align: SlidesApp.ParagraphAlignment.CENTER });

  addCucFooter(slide, layout, pageNum);
}

// content（1/2カラム + 小見出し + 画像）
function createContentSlide(slide, data, layout, pageNum) {
  slide.getBackground().setSolidFill(CONFIG.COLORS.background_white);
  drawStandardTitleHeader(slide, layout, 'contentSlide', data.title);
  const dy = drawSubheadIfAny(slide, layout, 'contentSlide', data.subhead);

  // アジェンダ安全装置
  const isAgenda = isAgendaTitle(data.title || '');
  let points = Array.isArray(data.points) ? data.points.slice(0) : [];
  if (isAgenda && (!points || points.length === 0)) {
    points = buildAgendaFromSlideData();
    if (points.length === 0) points = ['本日の目的', '進め方', '次のアクション'];
  }

  const hasImages = Array.isArray(data.images) && data.images.length > 0;
  const isTwo = !!(data.twoColumn || data.columns);

  if ((isTwo && (data.columns || points)) || (!isTwo && points && points.length > 0)) {
    if (isTwo) {
      let L = [], R = [];
      if (Array.isArray(data.columns) && data.columns.length === 2) {
        L = data.columns[0] || []; R = data.columns[1] || [];
      } else {
        const mid = Math.ceil(points.length / 2);
        L = points.slice(0, mid); R = points.slice(mid);
      }
      const leftRect = offsetRect(layout.getRect('contentSlide.twoColLeft'), 0, dy);
      const rightRect = offsetRect(layout.getRect('contentSlide.twoColRight'), 0, dy);
      const leftShape = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, leftRect.left, leftRect.top, leftRect.width, leftRect.height);
      const rightShape = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, rightRect.left, rightRect.top, rightRect.width, rightRect.height);
      setBulletsWithInlineStyles(leftShape, L);
      setBulletsWithInlineStyles(rightShape, R);
    } else {
      const bodyRect = offsetRect(layout.getRect('contentSlide.body'), 0, dy);
      if (isAgenda) {
        drawNumberedItems(slide, layout, bodyRect, points);
      } else {
        const bodyShape = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, bodyRect.left, bodyRect.top, bodyRect.width, bodyRect.height);
        setBulletsWithInlineStyles(bodyShape, points);
      }
    }
  }

  // 画像（任意）
  if (hasImages) {
    const area = offsetRect(layout.getRect('contentSlide.body'), 0, dy);
    renderImagesInArea(slide, layout, area, normalizeImages(data.images));
  }

  drawBottomBarAndFooter(slide, layout, pageNum);
}

// process（角枠1px＋一桁数字）
function createProcessSlide(slide, data, layout, pageNum) {
  slide.getBackground().setSolidFill(CONFIG.COLORS.background_white);
  drawStandardTitleHeader(slide, layout, 'processSlide', data.title);
  const dy = drawSubheadIfAny(slide, layout, 'processSlide', data.subhead);

  const area = offsetRect(layout.getRect('processSlide.area'), 0, dy);
  const steps = Array.isArray(data.steps) ? data.steps : [];
  const n = Math.max(1, steps.length);

  const topPadding = layout.pxToPt(30);
  const bottomPadding = layout.pxToPt(10);
  const drawableHeight = area.height - topPadding - bottomPadding;
  const gapY = drawableHeight / Math.max(1, n - 1);
  const cx = area.left + layout.pxToPt(44);
  const top0 = area.top + topPadding;

  const line = slide.insertShape(SlidesApp.ShapeType.RECTANGLE, cx - layout.pxToPt(1), top0 + layout.pxToPt(6), layout.pxToPt(2), gapY * (n - 1));
  line.getFill().setSolidFill(CONFIG.COLORS.faint_gray);
  line.getBorder().setTransparent();

  for (let i = 0; i < n; i++) {
    const cy = top0 + gapY * i;
    const sz = layout.pxToPt(28);
    const numBox = slide.insertShape(SlidesApp.ShapeType.RECTANGLE, cx - sz/2, cy - sz/2, sz, sz);
    numBox.getFill().setSolidFill(CONFIG.COLORS.primary_color);
    numBox.getBorder().setTransparent();
    const num = numBox.getText(); num.setText(String(i + 1));
    applyTextStyle(num, { size: 12, bold: true, color: CONFIG.COLORS.background_white, align: SlidesApp.ParagraphAlignment.CENTER });

    // 元のプロセステキストから先頭の数字を除去
    let cleanText = String(steps[i] || '');
    cleanText = cleanText.replace(/^\s*\d+[\.\s]*/, '');

    const txt = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, cx + layout.pxToPt(28), cy - layout.pxToPt(16), area.width - layout.pxToPt(70), layout.pxToPt(32));
    setStyledText(txt, cleanText, { size: CONFIG.FONTS.sizes.processStep });
    try { txt.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); } catch(e){}
  }

  drawBottomBarAndFooter(slide, layout, pageNum);
}

// cards（シンプルカード）
function createCardsSlide(slide, data, layout, pageNum) {
  slide.getBackground().setSolidFill(CONFIG.COLORS.background_white);
  drawStandardTitleHeader(slide, layout, 'cardsSlide', data.title);
  const dy = drawSubheadIfAny(slide, layout, 'cardsSlide', data.subhead);

  const area = offsetRect(layout.getRect('cardsSlide.gridArea'), 0, dy);
  const items = Array.isArray(data.items) ? data.items : [];
  const cols = Math.min(3, Math.max(2, Number(data.columns) || (items.length <= 4 ? 2 : 3)));
  const gap = layout.pxToPt(16);
  const rows = Math.ceil(items.length / cols);
  const cardW = (area.width - gap * (cols - 1)) / cols;
  const cardH = Math.max(layout.pxToPt(92), (area.height - gap * (rows - 1)) / rows);

  for (let idx = 0; idx < items.length; idx++) {
    const r = Math.floor(idx / cols), c = idx % cols;
    const left = area.left + c * (cardW + gap);
    const top  = area.top  + r * (cardH + gap);

    const card = slide.insertShape(SlidesApp.ShapeType.ROUND_RECTANGLE, left, top, cardW, cardH);
    card.getFill().setSolidFill(CONFIG.COLORS.card_bg);
    card.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.card_border);
    card.getBorder().setWeight(1);

    const obj = items[idx];
    if (typeof obj === 'string') {
      setStyledText(card, obj, { size: CONFIG.FONTS.sizes.body });
    } else {
      const title = String(obj.title || '');
      const desc  = String(obj.desc || '');
      
      if (title.length > 0 && desc.length > 0) {
        // タイトル + 改行 + 説明文
        const combined = `${title}\n\n${desc}`;
        setStyledText(card, combined, { size: CONFIG.FONTS.sizes.body });
        try { 
          card.getText().getRange(0, title.length).getTextStyle().setBold(true);
        } catch(e){}
      } else if (title.length > 0) {
        // タイトルのみ
        setStyledText(card, title, { size: CONFIG.FONTS.sizes.body, bold: true });
      } else {
        // 説明文のみ（稀なケース）
        setStyledText(card, desc, { size: CONFIG.FONTS.sizes.body });
      }
    }
    try { card.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); } catch(e) {}
  }

  drawBottomBarAndFooter(slide, layout, pageNum);
}

// headerCards（ヘッダー付きカード）
function createHeaderCardsSlide(slide, data, layout, pageNum) {
  slide.getBackground().setSolidFill(CONFIG.COLORS.background_white);
  drawStandardTitleHeader(slide, layout, 'cardsSlide', data.title);
  const dy = drawSubheadIfAny(slide, layout, 'cardsSlide', data.subhead);

  const area = offsetRect(layout.getRect('cardsSlide.gridArea'), 0, dy);
  const items = Array.isArray(data.items) ? data.items : [];
  const cols = Math.min(3, Math.max(2, Number(data.columns) || (items.length <= 4 ? 2 : 3)));
  const gap = layout.pxToPt(16);
  const rows = Math.ceil(items.length / cols);
  const cardW = (area.width - gap * (cols - 1)) / cols;
  const cardH = Math.max(layout.pxToPt(92), (area.height - gap * (rows - 1)) / rows);

  for (let idx = 0; idx < items.length; idx++) {
    const r = Math.floor(idx / cols), c = idx % cols;
    const left = area.left + c * (cardW + gap);
    const top  = area.top  + r * (cardH + gap);

    const obj = items[idx];
    const titleText = (typeof obj === 'string') ? '' : String(obj.title || '');
    const descText = (typeof obj === 'string') ? String(obj) : String(obj.desc || '');
    
    const headerHeight = layout.pxToPt(40);
    const headerShape = slide.insertShape(SlidesApp.ShapeType.RECTANGLE, left, top, cardW, headerHeight);
    headerShape.getFill().setSolidFill(CONFIG.COLORS.primary_color);
    headerShape.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.card_border);
    headerShape.getBorder().setWeight(1);
    
    const bodyShape = slide.insertShape(SlidesApp.ShapeType.RECTANGLE, left, top + headerHeight, cardW, cardH - headerHeight);
    bodyShape.getFill().setSolidFill(CONFIG.COLORS.card_bg);
    bodyShape.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.card_border);
    bodyShape.getBorder().setWeight(1);
    
    const headerTextShape = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, left, top, cardW, headerHeight);
    setStyledText(headerTextShape, titleText, { size: CONFIG.FONTS.sizes.body, bold: true, color: CONFIG.COLORS.background_white, align: SlidesApp.ParagraphAlignment.CENTER });
    try { headerTextShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); } catch(e){}

    const bodyTextShape = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, left, top + headerHeight, cardW, cardH - headerHeight);
    setStyledText(bodyTextShape, descText, { size: CONFIG.FONTS.sizes.body, align: SlidesApp.ParagraphAlignment.CENTER });
    try { bodyTextShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); } catch(e){}
  }

  drawBottomBarAndFooter(slide, layout, pageNum);
}

// bulletCards（箇条書きカード）
function createBulletCardsSlide(slide, data, layout, pageNum) {
  slide.getBackground().setSolidFill(CONFIG.COLORS.background_white);
  drawStandardTitleHeader(slide, layout, 'contentSlide', data.title);
  const dy = drawSubheadIfAny(slide, layout, 'contentSlide', data.subhead);

  const area = offsetRect(layout.getRect('contentSlide.body'), 0, dy);
  const items = Array.isArray(data.items) ? data.items : [];
  const totalItems = Math.min(items.length, 3);
  if (totalItems === 0) {
    drawBottomBarAndFooter(slide, layout, pageNum);
    return;
  }

  const gap = layout.pxToPt(16);
  const minCardHeight = layout.pxToPt(90);
  const maxCardHeight = layout.pxToPt(120);
  const idealCardHeight = (area.height - (totalItems - 1) * gap) / totalItems;
  const cardHeight = Math.max(minCardHeight, Math.min(maxCardHeight, idealCardHeight));
  
  let currentY = area.top;

  for (let i = 0; i < totalItems; i++) {
    const item = items[i];
    const card = slide.insertShape(SlidesApp.ShapeType.RECTANGLE, area.left, currentY, area.width, cardHeight);
    card.getFill().setSolidFill(CONFIG.COLORS.background_gray);
    card.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.card_border);
    card.getBorder().setWeight(1);

    const padding = layout.pxToPt(20);
    const title = String(item.title || '');
    const desc = String(item.desc || '');
    
    if (title.length > 0 && desc.length > 0) {
      const titleShape = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, area.left + padding, currentY + layout.pxToPt(12), area.width - padding * 2, layout.pxToPt(18));
      titleShape.getFill().setTransparent();
      titleShape.getBorder().setTransparent();
      setStyledText(titleShape, title, { size: 14, bold: true });
      
      const descShape = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, area.left + padding, currentY + layout.pxToPt(38), area.width - padding * 2, cardHeight - layout.pxToPt(48));
      descShape.getFill().setTransparent();
      descShape.getBorder().setTransparent();
      setStyledText(descShape, desc, { size: 14, color: CONFIG.COLORS.text_primary });
    } else if (title.length > 0) {
      const titleShape = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, area.left + padding, currentY, area.width - padding * 2, cardHeight);
      titleShape.getFill().setTransparent();
      titleShape.getBorder().setTransparent();
      titleShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);
      setStyledText(titleShape, title, { size: 14, bold: true });
    } else {
      const descShape = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, area.left + padding, currentY, area.width - padding * 2, cardHeight);
      descShape.getFill().setTransparent();
      descShape.getBorder().setTransparent();
      descShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);
      setStyledText(descShape, desc, { size: 14, color: CONFIG.COLORS.text_primary });
    }

    currentY += cardHeight + gap;
  }

  drawBottomBarAndFooter(slide, layout, pageNum);
}

// closing（結び）
function createClosingSlide(slide, data, layout) {
slide.getBackground().setSolidFill(CONFIG.COLORS.background_white);
try {
  const image = slide.insertImage(CONFIG.LOGOS.closing);
  const imgW_pt = layout.pxToPt(450) * layout.scaleX;
  const aspect = image.getHeight() / image.getWidth();
  image.setWidth(imgW_pt).setHeight(imgW_pt * aspect);
  image.setLeft((layout.pageW_pt - imgW_pt) / 2).setTop((layout.pageH_pt - (imgW_pt * aspect)) / 2);
} catch (e) {
  // 画像挿入に失敗した場合はスキップして他の要素を描画
}
}


// --- 8. ユーティリティ関数群 ---
function createLayoutManager(pageW_pt, pageH_pt) {
const pxToPt = (px) => px * 0.75;
const baseW_pt = pxToPt(CONFIG.BASE_PX.W);
const baseH_pt = pxToPt(CONFIG.BASE_PX.H);
const scaleX = pageW_pt / baseW_pt;
const scaleY = pageH_pt / baseH_pt;

const getPositionFromPath = (path) => path.split('.').reduce((obj, key) => obj[key], CONFIG.POS_PX);
return {
scaleX, scaleY, pageW_pt, pageH_pt, pxToPt,
getRect: (spec) => {
const pos = typeof spec === 'string' ? getPositionFromPath(spec) : spec;
let left_px = pos.left;
if (pos.right !== undefined && pos.left === undefined) {
left_px = CONFIG.BASE_PX.W - pos.right - pos.width;
}
return {
left:   left_px !== undefined ? pxToPt(left_px) * scaleX : undefined,
top:    pos.top !== undefined ? pxToPt(pos.top) * scaleY : undefined,
width:  pos.width !== undefined ? pxToPt(pos.width) * scaleX : undefined,
height: pos.height !== undefined ? pxToPt(pos.height) * scaleY : undefined,
};
}
};
}

function offsetRect(rect, dx, dy) {
return { left: rect.left + (dx || 0), top: rect.top + (dy || 0), width: rect.width, height: rect.height };
}

function drawStandardTitleHeader(slide, layout, key, title) {
const logoRect = layout.getRect(`${key}.headerLogo`);
try {
  const logo = slide.insertImage(CONFIG.LOGOS.header);
  const asp = logo.getHeight() / logo.getWidth();
  logo.setLeft(logoRect.left).setTop(logoRect.top).setWidth(logoRect.width).setHeight(logoRect.width * asp);
} catch (e) {
  // 画像挿入に失敗した場合はスキップして他の要素を描画
}

const titleRect = layout.getRect(`${key}.title`);
const titleShape = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, titleRect.left, titleRect.top, titleRect.width, titleRect.height);
setStyledText(titleShape, title || '', { size: CONFIG.FONTS.sizes.contentTitle, bold: true });

const uRect = layout.getRect(`${key}.titleUnderline`);
const u = slide.insertShape(SlidesApp.ShapeType.RECTANGLE, uRect.left, uRect.top, uRect.width, uRect.height);
u.getFill().setSolidFill(CONFIG.COLORS.primary_color);
u.getBorder().setTransparent();
}

function drawSubheadIfAny(slide, layout, key, subhead) {
if (!subhead) return 0;
const rect = layout.getRect(`${key}.subhead`);
const box = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, rect.left, rect.top, rect.width, rect.height);
setStyledText(box, subhead, { size: CONFIG.FONTS.sizes.subhead, color: CONFIG.COLORS.text_primary });
return layout.pxToPt(36);
}

function drawBottomBar(slide, layout) {
const barRect = layout.getRect('bottomBar');
const bar = slide.insertShape(SlidesApp.ShapeType.RECTANGLE, barRect.left, barRect.top, barRect.width, barRect.height);
bar.getFill().setSolidFill(CONFIG.COLORS.primary_color);
bar.getBorder().setTransparent();
}

function drawBottomBarAndFooter(slide, layout, pageNum) {
drawBottomBar(slide, layout);
addCucFooter(slide, layout, pageNum);
}

function addCucFooter(slide, layout, pageNum) {
const leftRect = layout.getRect('footer.leftText');
const leftShape = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, leftRect.left, leftRect.top, leftRect.width, leftRect.height);
leftShape.getText().setText(CONFIG.FOOTER_TEXT);
applyTextStyle(leftShape.getText(), { size: CONFIG.FONTS.sizes.footer, color: CONFIG.COLORS.text_primary });

if (pageNum > 0) {
const rightRect = layout.getRect('footer.rightPage');
const rightShape = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, rightRect.left, rightRect.top, rightRect.width, rightRect.height);
rightShape.getText().setText(String(pageNum));
applyTextStyle(rightShape.getText(), { size: CONFIG.FONTS.sizes.footer, color: CONFIG.COLORS.primary_color, align: SlidesApp.ParagraphAlignment.END });
}
}

function applyTextStyle(textRange, opt) {
const style = textRange.getTextStyle();
style.setFontFamily(CONFIG.FONTS.family);
style.setForegroundColor(opt.color || CONFIG.COLORS.text_primary);
style.setFontSize(opt.size || CONFIG.FONTS.sizes.body);
style.setBold(opt.bold || false);
if (opt.align) {
try { textRange.getParagraphs().forEach(p => p.getRange().getParagraphStyle().setParagraphAlignment(opt.align)); } catch (e) {}
}
}

function setStyledText(shapeOrCell, rawText, baseOpt) {
const parsed = parseInlineStyles(rawText || '');
const tr = shapeOrCell.getText();
tr.setText(parsed.output);
applyTextStyle(tr, baseOpt || {});
applyStyleRanges(tr, parsed.ranges);
}

function setBulletsWithInlineStyles(shape, points) {
const joiner = '\n\n';
let combined = '';
const ranges = [];

(points || []).forEach((pt, idx) => {
const parsed = parseInlineStyles(String(pt || ''));
const bullet = '• ' + parsed.output;
if (idx > 0) combined += joiner;
const start = combined.length;
combined += bullet;

parsed.ranges.forEach(r => {
  ranges.push({ start: start + 2 + r.start, end: start + 2 + r.end, bold: r.bold, color: r.color });
});
});

const tr = shape.getText();
tr.setText(combined || '• —');
applyTextStyle(tr, { size: CONFIG.FONTS.sizes.body });

try {
tr.getParagraphs().forEach(p => {
const ps = p.getRange().getParagraphStyle();
ps.setLineSpacing(100);
ps.setSpaceBelow(6);
});
} catch (e) {}

applyStyleRanges(tr, ranges);
}

function parseInlineStyles(s) {
const ranges = [];
let out = '';
for (let i = 0; i < s.length; ) {
if (s[i] === '[' && s[i+1] === '[') {
const close = s.indexOf(']]', i + 2);
if (close !== -1) {
const content = s.substring(i + 2, close);
const start = out.length;
out += content;
const end = out.length;
ranges.push({ start, end, bold: true, color: CONFIG.COLORS.primary_color });
i = close + 2; continue;
}
}
if (s[i] === '*' && s[i+1] === '*') {
const close = s.indexOf('**', i + 2);
if (close !== -1) {
const content = s.substring(i + 2, close);
const start = out.length;
out += content;
const end = out.length;
ranges.push({ start, end, bold: true });
i = close + 2; continue;
}
}
out += s[i]; i++;
}
return { output: out, ranges };
}

function applyStyleRanges(textRange, ranges) {
ranges.forEach(r => {
try {
const sub = textRange.getRange(r.start, r.end);
if (!sub) return;
const st = sub.getTextStyle();
if (r.bold) st.setBold(true);
if (r.color) st.setForegroundColor(r.color);
} catch (e) {}
});
}

function normalizeImages(arr) {
return (arr || []).map(v => {
if (typeof v === 'string') return { url: v };
if (v && typeof v.url === 'string') return { url: v.url, caption: v.caption || '' };
return null;
}).filter(Boolean).slice(0, 6);
}

function renderImagesInArea(slide, layout, area, images) {
if (!images || images.length === 0) return;
const n = Math.min(6, images.length);
let cols = 1, rows = 1;
if (n === 1) { cols = 1; rows = 1; }
else if (n === 2) { cols = 2; rows = 1; }
else if (n <= 4) { cols = 2; rows = 2; }
else { cols = 3; rows = 2; }

const gap = layout.pxToPt(10);
const cellW = (area.width - gap * (cols - 1)) / cols;
const cellH = (area.height - gap * (rows - 1)) / rows;

for (let i = 0; i < n; i++) {
const r = Math.floor(i / cols), c = i % cols;
const left = area.left + c * (cellW + gap);
const top  = area.top  + r * (cellH + gap);
try {
const img = slide.insertImage(images[i].url);
const scale = Math.min(cellW / img.getWidth(), cellH / img.getHeight());
const w = img.getWidth() * scale;
const h = img.getHeight() * scale;
img.setWidth(w).setHeight(h);
img.setLeft(left + (cellW - w) / 2).setTop(top + (cellH - h) / 2);
} catch(e) {}
}
}

function isAgendaTitle(title) {
const t = String(title || '').toLowerCase();
return /(agenda|アジェンダ|目次|本日お伝えすること)/.test(t);
}

function buildAgendaFromSlideData() {
const pts = [];
for (const d of slideData) {
if (d && d.type === 'section' && typeof d.title === 'string' && d.title.trim()) pts.push(d.title.trim());
}
if (pts.length > 0) return pts.slice(0, 5);
const alt = [];
for (const d of slideData) {
if (d && d.type === 'content' && typeof d.title === 'string' && d.title.trim()) alt.push(d.title.trim());
}
return alt.slice(0, 5);
}

function drawNumberedItems(slide, layout, area, items) {
const n = Math.max(1, items.length);
const topPadding = layout.pxToPt(30);
const bottomPadding = layout.pxToPt(10);
const drawableHeight = area.height - topPadding - bottomPadding;
const gapY = drawableHeight / Math.max(1, n - 1);
const cx = area.left + layout.pxToPt(44);
const top0 = area.top + topPadding;

for (let i = 0; i < n; i++) {
const cy = top0 + gapY * i;
const sz = layout.pxToPt(28);
const numBox = slide.insertShape(SlidesApp.ShapeType.RECTANGLE, cx - sz/2, cy - sz/2, sz, sz);
numBox.getFill().setSolidFill(CONFIG.COLORS.primary_color);
numBox.getBorder().setTransparent();
const num = numBox.getText(); num.setText(String(i + 1));
applyTextStyle(num, { size: 12, bold: true, color: CONFIG.COLORS.background_white, align: SlidesApp.ParagraphAlignment.CENTER });

// 元の箇条書きテキストから先頭の数字を除去
let cleanText = String(items[i] || '');
cleanText = cleanText.replace(/^\s*\d+[\.\s]*/, '');

const txt = slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, cx + layout.pxToPt(28), cy - layout.pxToPt(16), area.width - layout.pxToPt(70), layout.pxToPt(32));
setStyledText(txt, cleanText, { size: CONFIG.FONTS.sizes.processStep });
try { txt.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); } catch(e){}
}
}
